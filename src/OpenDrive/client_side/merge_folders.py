"""
:module: OpenDrive.client_side.merge_folders
:synopsis: Merge files and of two folders, based on a merge method.
:author: Julian Sobott

This is needed, when a folder is synced with an existing folder.

Dict structure for content of a folder:

    Folder:
        "folder_name": top_folder_name,
        "files": List[Dict["filename": str, "modified_timestamp": str]
        "folders": List[Folder]

    e.g.

    {
    "folder_name": "top",
    "files": [{"file_name": "test.txt", "modified_timestamp": 1234}, ...],
    "folders": [{"folder_name": ...},{...}, ...]
    }

public classes
---------------

.. autoclass:: MergeMethods
    :members:


public functions
----------------

.. autofunction:: merge_two_folders

private functions
-----------------

.. autofunction:: _take_1
.. autofunction:: _take_2

"""
from enum import auto
from typing import Tuple, List, Callable, NewType

from OpenDrive.general.file_exchanges import SyncAction
from OpenDrive.general import merge_folders as gen_merge_folders
from OpenDrive.general import file_changes_json as gen_json
from OpenDrive.general.paths import normalize_path
from OpenDrive.client_side import synchronization as c_syc
from OpenDrive.client_side import synchronization as client_sync
from OpenDrive.client_side import interface
from OpenDrive import net_interface

MergeMethod = NewType("MergeMethod", Callable)


def merge_folders(abs_local_path: str, remote_name: str, merge_method: MergeMethod) -> 'interface.Status':
    try:
        server_content = net_interface.server.generate_content_of_folder(remote_name)
    except FileNotFoundError:
        return interface.Status.fail(f"Server folder ({remote_name}) does not exist!")
    try:
        client_content = gen_merge_folders.generate_content_of_folder(abs_local_path)
    except FileNotFoundError:
        return interface.Status.fail(f"Client folder ({abs_local_path}) does not exist!")
    client_actions, server_actions = merge_two_folders(client_content, server_content, merge_method)
    net_interface.server.execute_actions(server_actions)
    client_sync.execute_client_actions(client_actions)
    return interface.Status.success("Successfully merged folders")


def merge_two_folders(folder_1_content: dict, folder_2_content: dict, merge_method: MergeMethod):
    """Merges two folders content. Returns actions for both folders. The contents are generated by
    :func:`generate_content_of_folder`
    """
    return merge_method(folder_1_content, folder_2_content)


def _take_1(folder_1_content: dict, folder_2_content: dict) -> Tuple[List[SyncAction], List[SyncAction]]:
    f1_actions = []
    f2_actions = []
    f1_folder_name = folder_1_content["folder_name"]
    f2_folder_name = folder_2_content["folder_name"]

    f2_actions.append(c_syc.create_action(f2_folder_name, normalize_path(""), gen_json.ACTION_DELETE, True))
    f2_actions.append(c_syc.create_action(f2_folder_name, normalize_path(""), gen_json.ACTION_PULL, True,
                                          remote_abs_path=f1_folder_name))
    return f1_actions, f2_actions


def _take_2(folder_1_content: dict, folder_2_content: dict) -> Tuple[List[SyncAction], List[SyncAction]]:
    f1_actions, f2_actions = _take_1(folder_2_content, folder_1_content)
    return f2_actions, f1_actions


def _prioritize_latest(folder_1_content: dict, folder_2_content: dict) -> Tuple[List[SyncAction], List[SyncAction]]:
    f1_actions = []
    f2_actions = []
    f1_folder_name = folder_1_content["folder_name"]
    f2_folder_name = folder_2_content["folder_name"]

    new_f1_actions, new_f2_actions = _prioritize_latest_recursive(folder_1_content, folder_2_content, f1_folder_name,
                                                                  f2_folder_name)
    f1_actions += new_f1_actions
    f2_actions += new_f2_actions
    new_f2_actions, new_f1_actions = _prioritize_latest_recursive(folder_2_content, folder_1_content, f2_folder_name,
                                                                  f1_folder_name)
    f1_actions += new_f1_actions
    f2_actions += new_f2_actions

    # folder: not exists -> pull folder
    # file: not exists -> pull
    # file: exists -> take latest
    return f1_actions, f2_actions


def _prioritize_latest_recursive(folder_1_content: dict, folder_2_content: dict, f1_path: str, f2_path: str):
    f1_actions = []
    f2_actions = []
    f1_files: list = folder_1_content["files"]
    f2_files: list = folder_2_content["files"]

    f2_file_names = [file["file_name"] for file in f2_files]
    for file in f1_files:
        if file["file_name"] in f2_file_names:
            f2_idx = f2_file_names.index(file["file_name"])
            if f2_files[f2_idx]["timestamp"] > file["timestamp"]:
                take_from_folder = 2
            else:
                take_from_folder = 1
            f2_files.pop(f2_idx)
        else:
            take_from_folder = 1

        if take_from_folder == 1:
            f2_actions.append(c_syc.create_action(normalize_path(f2_path), normalize_path(file["filename"]),
                                                  gen_json.ACTION_PULL, False,
                                                  remote_abs_path=normalize_path(f1_path, file["file_name"])))
        else:
            f1_actions.append(c_syc.create_action(normalize_path(f1_path), normalize_path(file["filename"]),
                                                  gen_json.ACTION_PULL, False,
                                                  remote_abs_path=normalize_path(f2_path, file["file_name"])))
    f1_files.clear()
    # TODO: merge folders in folders
    return f1_actions, f2_actions


class MergeMethods:
    TAKE_1: MergeMethod = MergeMethod(_take_1)  #: Clear 2 and copy 1 into it
    TAKE_2 = MergeMethod(_take_2)  #: Clear 1 and copy 2 into it
    COMPLETE_BOTH = auto()  #: Copies missing files at both sides
    CONFLICTS: Callable = auto()  #: MERGE_COMPLETE_BOTH + create conflicts for files, that exists on both sides
    PRIORITIZE_1: Callable = auto()  #: MERGE_COMPLETE_BOTH + files that exists at both sides are taken from 1
    PRIORITIZE_2: Callable = auto()  #: MERGE_COMPLETE_BOTH + files that exists at both sides are taken from 2
    #: MERGE_COMPLETE_BOTH + files that exists at both sides, the latest changed is taken
    PRIORITIZE_LATEST: MergeMethod = MergeMethod(_prioritize_latest)
    DEFAULT = TAKE_1
