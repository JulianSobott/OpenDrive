"""
:module: OpenDrive.client_side.merge_folders
:synopsis: Merge files and of two folders, based on a merge method.
:author: Julian Sobott

This is needed, when a folder is synced with an existing folder.

Dict structure for content of a folder:

    Folder:
        "folder_name": top_folder_name,
        "files": List[Dict["filename": str, "modified_timestamp": str]
        "folders": List[Folder]

    e.g.

    {
    "folder_name": "top",
    "files": [{"file_name": "test.txt", "modified_timestamp": 1234}, ...],
    "folders": [{"folder_name": ...},{...}, ...]
    }

public classes
---------------

.. autoclass:: MergeMethods
    :members:


public functions
----------------

.. autofunction:: merge_two_folders

private functions
-----------------

.. autofunction:: _take_1
.. autofunction:: _take_2

"""
from enum import auto
from typing import Tuple, List, Callable, NewType

from OpenDrive.general.file_exchanges import SyncAction
from OpenDrive.general import merge_folders as gen_merge_folders
from OpenDrive.general import file_changes_json as gen_json
from OpenDrive.general.paths import normalize_path, NormalizedPath
from OpenDrive.client_side import synchronization as c_syc
from OpenDrive.client_side import synchronization as client_sync
from OpenDrive.client_side import interface
from OpenDrive import net_interface

MergeMethod = NewType("MergeMethod", Callable)


def merge_folders(abs_local_path: str, remote_name: str, merge_method: MergeMethod) -> 'interface.Status':
    try:
        server_content = net_interface.server.generate_content_of_folder(remote_name)
    except FileNotFoundError:
        return interface.Status.fail(f"Server folder ({remote_name}) does not exist!")
    try:
        client_content = gen_merge_folders.generate_content_of_folder(abs_local_path)
    except FileNotFoundError:
        return interface.Status.fail(f"Client folder ({abs_local_path}) does not exist!")
    client_actions, server_actions = merge_two_folders(client_content, server_content, merge_method)
    net_interface.server.execute_actions(server_actions)
    client_sync.execute_client_actions(client_actions)
    return interface.Status.success("Successfully merged folders")


def merge_two_folders(folder_1_content: dict, folder_2_content: dict, merge_method: MergeMethod):
    """Merges two folders content. Returns actions for both folders. The contents are generated by
    :func:`generate_content_of_folder`
    """
    return merge_method(folder_1_content, folder_2_content)


def _take_1(folder_1_content: dict, folder_2_content: dict) -> Tuple[List[SyncAction], List[SyncAction]]:
    f1_actions = []
    f2_actions = []
    f1_folder_name = folder_1_content["folder_name"]
    f2_folder_name = folder_2_content["folder_name"]

    f2_actions.append(c_syc.create_action(f2_folder_name, normalize_path(""), gen_json.ACTION_DELETE, True))
    f2_actions.append(c_syc.create_action(f2_folder_name, normalize_path(""), gen_json.ACTION_PULL, True,
                                          remote_abs_path=f1_folder_name))
    return f1_actions, f2_actions


def _take_2(folder_1_content: dict, folder_2_content: dict) -> Tuple[List[SyncAction], List[SyncAction]]:
    f1_actions, f2_actions = _take_1(folder_2_content, folder_1_content)
    return f2_actions, f1_actions


def _prioritize_latest(folder_1_content: dict, folder_2_content: dict) -> Tuple[List[SyncAction], List[SyncAction]]:
    return _prioritize_latest_recursive(folder_1_content, folder_2_content, folder_1_content["folder_name"],
                                        folder_2_content["folder_name"], normalize_path(""))


def _prioritize_latest_recursive(folder_1_content: dict, folder_2_content: dict, f1_path: NormalizedPath,
                                 f2_path: NormalizedPath, rel_path: NormalizedPath):
    f1_actions = []
    f2_actions = []
    f1_files: list = folder_1_content["files"]
    f2_files: list = folder_2_content["files"]

    new_f1_actions, new_f2_actions = _merge_files_latest(f1_files, f2_files, f1_path, f2_path, rel_path)
    f1_actions += new_f1_actions
    f2_actions += new_f2_actions

    f1_folders: list = folder_1_content["folders"]
    f2_folders: list = folder_2_content["folders"]
    new_f1_actions, new_f2_actions = _merge_folders_latest(f1_folders, f2_folders, f1_path, f2_path, rel_path)
    f1_actions += new_f1_actions
    f2_actions += new_f2_actions

    return f1_actions, f2_actions


def _merge_files_latest(files1: List[dict], files2: List[dict], f1_path: NormalizedPath, f2_path: NormalizedPath,
                        rel_path: NormalizedPath):
    f1_actions = []
    f2_actions = []
    f2_file_names = [file["file_name"] for file in files2]
    for f1 in files1:
        try:
            idx = f2_file_names.index(f1["file_name"])
            f2 = files2[idx]
            if f1["modified_timestamp"] > f2["modified_timestamp"]:
                take_1 = True
            else:
                take_1 = False
            f2_file_names.pop(idx)
            files2.pop(idx)
        except ValueError:
            take_1 = True
        if take_1:
            f2_actions.append(c_syc.create_action(normalize_path(f2_path), normalize_path(rel_path, f1["file_name"]),
                                                  gen_json.ACTION_PULL, False,
                                                  remote_abs_path=normalize_path(f1_path, rel_path, f1["file_name"])))
        else:
            f1_actions.append(c_syc.create_action(normalize_path(f1_path), normalize_path(rel_path, f1["file_name"]),
                                                  gen_json.ACTION_PULL, False,
                                                  remote_abs_path=normalize_path(f2_path, rel_path, f1["file_name"])))
    files1.clear()
    if len(files2) > 0:
        new_f2_actions, new_f1_actions = _merge_files_latest(files2, files1, f2_path, f1_path, rel_path)
        f1_actions += new_f1_actions
        f2_actions += new_f2_actions
    return f1_actions, f2_actions


def _merge_folders_latest(folders1: List[dict], folders2: List[dict], f1_path: NormalizedPath, f2_path: NormalizedPath,
                          rel_path: NormalizedPath):
    f1_actions = []
    f2_actions = []
    f2_folder_names = [folder["folder_name"] for folder in folders2]
    for f1 in folders1:
        try:
            idx = f2_folder_names.index(f1["folder_name"])
            f2 = folders2[idx]
            new_rel_path = normalize_path(rel_path, f1["folder_name"])
            new_f1_actions, new_f2_actions = _prioritize_latest_recursive(f1["files"], f2["files"],
                                                                          f1_path, f2_path, new_rel_path)
            f1_actions += new_f1_actions
            f2_actions += new_f2_actions
            f2_folder_names.pop(idx)
            folders2.pop(idx)
        except ValueError:
            rel_file_path = normalize_path(rel_path, f1["folder_name"])
            remote_abs_path = normalize_path(f1_path, rel_path, f1["folder_name"])
            f2_actions.append(c_syc.create_action(normalize_path(f2_path), rel_file_path, gen_json.ACTION_PULL,
                                                  True, remote_abs_path=remote_abs_path))
    if len(folders2) > 0:
        new_f2_actions, new_f1_actions = _merge_folders_latest(folders2, folders1, f2_path, f1_path, rel_path)
        f1_actions += new_f1_actions
        f2_actions += new_f2_actions
    return f1_actions, f2_actions


class MergeMethods:
    TAKE_1: MergeMethod = MergeMethod(_take_1)  #: Clear 2 and copy 1 into it
    TAKE_2 = MergeMethod(_take_2)  #: Clear 1 and copy 2 into it
    COMPLETE_BOTH = auto()  #: Copies missing files at both sides
    CONFLICTS: Callable = auto()  #: MERGE_COMPLETE_BOTH + create conflicts for files, that exists on both sides
    PRIORITIZE_1: Callable = auto()  #: MERGE_COMPLETE_BOTH + files that exists at both sides are taken from 1
    PRIORITIZE_2: Callable = auto()  #: MERGE_COMPLETE_BOTH + files that exists at both sides are taken from 2
    #: MERGE_COMPLETE_BOTH + files that exists at both sides, the latest changed is taken
    PRIORITIZE_LATEST: MergeMethod = MergeMethod(_prioritize_latest)
    DEFAULT = TAKE_1
