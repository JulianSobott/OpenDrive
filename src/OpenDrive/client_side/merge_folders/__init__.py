"""
:module: OpenDrive.client_side.merge_folders
:synopsis: Merges two folders, so that in the end both folders have the exact same content.
:author: Julian Sobott

This is needed, when a folder is synced with an existing folder. There are several merge methods available,
that define how both folders are merged.

Dict structure for content of a folder:
----------------------------------------

::

    Folder:
        "folder_name": top_folder_name,
        "files": List[Dict["filename": str, "modified_timestamp": str]
        "folders": List[Folder]

    e.g.

    {
    "folder_name": "top",
    "files": [{"file_name": "test.txt", "modified_timestamp": 1234}, ...],
    "folders": [{"folder_name": ...},{...}, ...]
    }


Creating a new merge method
----------------------------

- name the module the same as the method
- Set NAME, DESCRIPTION variables in the module
- Implement the function
- Create an alias of the function with: method = {function_name}
- Add the module in class:`MergeMethods`

public classes
---------------

.. autoclass:: MergeMethods
    :members:


public functions
----------------

.. autofunction:: merge_folders
.. autofunction:: generate_merge_actions

inner modules:
---------------

.. automodule:: OpenDrive.client_side.merge_folders.take_1

----------------------------------------------

.. automodule:: OpenDrive.client_side.merge_folders.take_2

----------------------------------------------

.. automodule:: OpenDrive.client_side.merge_folders.prioritize_latest

"""
from typing import NewType, Any


from OpenDrive.general import merge_folders as gen_merge_folders
from OpenDrive.client_side import synchronization as client_sync
from OpenDrive.client_side import interface
from OpenDrive import net_interface
from OpenDrive.client_side.merge_folders import take_1, take_2, prioritize_latest

MergeMethod = NewType("MergeMethod", Any)

__all__ = ["MergeMethods", "MergeMethod", "merge_folders", "generate_merge_actions"]


class MergeMethods:
    #: Clear 2 and copy 1 into it
    TAKE_1: MergeMethod = MergeMethod(take_1)

    #: Clear 1 and copy 2 into it
    TAKE_2: MergeMethod = MergeMethod(take_2)

    #: Copies missing files at both sides
    COMPLETE_BOTH: MergeMethod = NotImplemented

    #: MERGE_COMPLETE_BOTH + create conflicts for files, that exists on both sides
    CONFLICTS: MergeMethod = NotImplemented

    #: MERGE_COMPLETE_BOTH + files that exists at both sides are taken from 1
    PRIORITIZE_1: MergeMethod = NotImplemented

    #: MERGE_COMPLETE_BOTH + files that exists at both sides are taken from 2
    PRIORITIZE_2: MergeMethod = NotImplemented

    #: MERGE_COMPLETE_BOTH + files that exists at both sides, the latest changed is taken
    PRIORITIZE_LATEST: MergeMethod = MergeMethod(prioritize_latest)

    DEFAULT = TAKE_1


def merge_folders(abs_local_path: str, remote_name: str, merge_method: MergeMethod) -> 'interface.Status':
    try:
        server_content = net_interface.server.generate_content_of_folder(remote_name)
    except FileNotFoundError:
        return interface.Status.fail(f"Server folder ({remote_name}) does not exist!")
    try:
        client_content = gen_merge_folders.generate_content_of_folder(abs_local_path)
    except FileNotFoundError:
        return interface.Status.fail(f"Client folder ({abs_local_path}) does not exist!")
    client_actions, server_actions = generate_merge_actions(client_content, server_content, merge_method)
    net_interface.server.execute_actions(server_actions)
    client_sync.execute_client_actions(client_actions)
    return interface.Status.success("Successfully merged folders")


def generate_merge_actions(folder_1_content: dict, folder_2_content: dict, merge_method: MergeMethod):
    """Merges two folders content. Returns actions for both folders. The contents are generated by
    :func:`generate_content_of_folder`
    """
    return merge_method.method(folder_1_content, folder_2_content)
